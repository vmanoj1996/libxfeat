// Minimal MEX wrapper - validation moved to MATLAB side
// This wrapper is just for ensuring the correctness of the conv2d operation
#include "mex.h"
#include "conv2d.h"
#include <cuda_runtime.hpp>

enum InputArgs
{
    ARG_INPUT = 0,
    ARG_KERNEL = 1,
    ARG_K1 = 2,
    ARG_K2 = 3,
    ARG_S1 = 4,
    ARG_S2 = 5,
    ARG_P1 = 6,
    ARG_P2 = 7,
    TOTAL_ARGS = 8
};

enum OutputArgs
{
    OUT_RESULT = 0,
    TOTAL_OUTPUTS = 1
};

// Input dimension indices
enum InputDims
{
    IDX_INPUT_CI = 0,
    IDX_INPUT_HEIGHT = 1,
    IDX_INPUT_WIDTH = 2
};

enum KernelDims
{
    IDX_KERNEL_CO = 0,
    IDX_KERNEL_CI = 1,
    IDX_KERNEL_K1 = 2,
    IDX_KERNEL_K2 = 3
};

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    // Basic argument count check only
    if (nrhs != TOTAL_ARGS || nlhs != TOTAL_OUTPUTS)
    {
        mexErrMsgTxt("Usage: output = conv2d_mex(input, kernel, k1, k2, s1, s2, p1, p2)");
    }

    // Get dimensions (assume MATLAB validated them)
    const mwSize* input_dims  = mxGetDimensions(prhs[ARG_INPUT]);
    const mwSize* kernel_dims = mxGetDimensions(prhs[ARG_KERNEL]);

    int ci      = input_dims[IDX_INPUT_CI];
    int input_h = input_dims[IDX_INPUT_HEIGHT];
    int input_w = input_dims[IDX_INPUT_WIDTH];
    int co      = kernel_dims[IDX_KERNEL_CO];
    

    // Get parameters
    int k1 = (int)mxGetScalar(prhs[ARG_K1]);
    int k2 = (int)mxGetScalar(prhs[ARG_K2]);
    int s1 = (int)mxGetScalar(prhs[ARG_S1]);
    int s2 = (int)mxGetScalar(prhs[ARG_S2]);
    int p1 = (int)mxGetScalar(prhs[ARG_P1]);
    int p2 = (int)mxGetScalar(prhs[ARG_P2]);

    try
    {
        // Create convolution
        ImgProperty input_prop = {input_h, input_w};
        Conv2DParams params = {k1, k2, ci, co, s1, s2, p1, p2};
        Convolve2D conv(input_prop, params);

        // Set kernel
        FLOAT* kernel_data = (FLOAT*)mxGetData(prhs[ARG_KERNEL]);
        size_t kernel_size = co * ci * k1 * k2;
        std::vector<FLOAT> kernel_vec(kernel_data, kernel_data + kernel_size);
        conv.set_kernel(kernel_vec);

        // GPU input
        FLOAT* input_data = (FLOAT*)mxGetData(prhs[ARG_INPUT]);
        FLOAT *input_device;
        cudaMalloc(&input_device, ci * input_h * input_w * sizeof(FLOAT));
        cudaMemcpy(input_device, input_data, ci * input_h * input_w * sizeof(FLOAT), cudaMemcpyHostToDevice);

        // Forward pass
        conv.forward(input_device);

        // Create output
        ImgProperty output_spec = conv.get_output_spec();
        mwSize output_dims[3] = {static_cast<mwSize>(co),
                                 static_cast<mwSize>(output_spec.height),
                                 static_cast<mwSize>(output_spec.width)};

        plhs[OUT_RESULT] = mxCreateNumericArray(3, output_dims, mxSINGLE_CLASS, mxREAL);

        // Copy result
        FLOAT *output_data = (FLOAT *)mxGetData(plhs[0]);
        cudaMemcpy(output_data, conv.get_output(),
                   co * output_spec.height * output_spec.width * sizeof(FLOAT),
                   cudaMemcpyDeviceToHost);

        cudaFree(input_device);
    }
    catch (const std::exception &e)
    {
        mexErrMsgTxt(e.what());
    }
}